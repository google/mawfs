## High-level workflows.

import crack.fs Path;
import crack.functor Functor0;
import crack.lang Exception;
import crack.logger debug, info;
import crack.threads Mutex, MutexLock, Queue, Thread;

import .blockstore ChunkStore;
import .peernet PeerNetwork;
import .rawchunk GeneralCallback;
import .rpc InstIFace;

@import crack.ann cvars, define, impl;

alias Task = Functor0[void];

## The thread pool used to run flows. It's currently just a single thread.
##
## Use the submit() method to submit tasks for execution, submit a task that
## evaluates to "false" to kill the thread.
class ThreadPool {
    Mutex __mutex = {};
    Queue[Task] __queue = {};

    class __Thread : Thread {
        @cvars { Queue[Task] __queue; }

        void run() {
            info `Worker thread pool started.`;
            while (task := __queue.get())
                task();
            info `Worker thread pool terminating.`;
        }
    }

    __Thread __thread;

    void __start() {
        MutexLock lock = {__mutex};
        if (!__thread) {
            __thread = __Thread(__queue);
            __thread.start();
        }
    }

    ## Subit a task for execution.
    void submit(Task task) {
        __start();
        __queue.add(task);
        if (!task) {
            lock := MutexLock(__mutex);
            __thread = null;
        }
    }
}

ThreadPool __pool = {};

@define task(vars, action) {
    class MyTask @impl Task {
        @cvars {
            vars
            GeneralCallback[String] callback;
        }

        void oper call() {
            String result;
            Exception exception;
            try {
                result = (action);
            } catch (Exception ex) {
                exception = ex;
            }
            callback(result, exception);
        }
    }
}

import crack.io cerr;
class MAWFSInstance @impl InstIFace {
    Path __root;
    ChunkStore __store;
    PeerNetwork __net;

    oper init(Path root, ChunkStore store, PeerNetwork net) :
        __root = root,
        __store = store,
        __net = net {
    }

    ## Returns true if the commit derives from the ancestor.
    ##
    ## TODO: Improve this algorithm.  We're just using a simple recursive
    ## depth-first search for this, that's bound to be inefficient considering
    ## the way branching is likely to play out.
    bool derivesFrom(String commitDigest, String ancestorDigest) {
        if (commitDigest == ancestorDigest)
            return true;

        commit := __store.getCommit(commitDigest);
        bool result;
        if (commit.parent) {
            for (parent :in commit.parent) {
                if (derivesFrom(parent, ancestorDigest))
                    result = true;
            }
        }
        return result;
    }

    ## Pull a branch from a peer to the local instance.  This can result in the
    ## production of a tracking branch.
    String pullBranch(String name, String peer) {
        localHead := __store.getHead(name);
        String newName;
        if (!localHead) {
            # The branch isn't present locally, so we can pull it.
            __net.pullJournal(__root, name, false);
            newName = name;
        } else {
            # Pull the journal to a temporary name.
            newName = __net.pullJournal(__root, name, true);
        }

        jiter := __store.makeJournalIter(newName);
        if (!jiter) {
            # Try pulling the commit.
            head := __net.getHead(name);
            if (!head)
                throw Exception('Unable to retrieve branch');

            if (localHead) {
                # This is a new commit.  See if the current commit is a direct
                # ancestor.
                if (derivesFrom(head, localHead))
                    # If the new head derives from the local head, we're
                    # going to want to store the new head and we can subsume
                    # the old branch.
                    newName = name;
                else if (derivesFrom(localHead, head))
                    # If the local head inherits from the new head, then the
                    # local head extends the new remote head and we can
                    # ignore the new remote head.
                    return name;
            }

            __store.setHead(newName, head);
            return newName;
        }
        __store.setHead(newName, newHead := jiter.elem().change.commit);

        if (name == newName) {
            return name;
        } else {
            # There was an existing branch, compare it to the new one.
            localJiter := __store.makeJournalIter(name);
            if (!localJiter) {
                # No local journal - we're done unless the new commit derives
                # from the old one.  If that's true, fall through and we'll
                # enter the logic for "a remote journal extending a local
                # journal" below.
                if (!derivesFrom(newHead, localHead))
                    return newName;
            } else if (!localJiter || localJiter.elem().change.commit != newHead) {
                return newName;
            }

            while (jiter && localJiter) {
                if (jiter.elem().change != localJiter.elem().change)
                    break;
                jiter.next();
                localJiter.next();
            }

            if (jiter && !localJiter) {
                # The new journal extends the old one.  We can just accept the
                # new journal.
                # TODO: move the "move branch" functionality to the chunk store.
                (__root/'journals'/newName).moveTo(__root/'journals'/name);
                (__root/'refs'/newName).moveTo(__root/'refs'/name);
                return name;
            } else if ((localJiter && !jiter) || (!jiter && !localJiter)) {
                # Either the journals are the same or the old journal extends
                # the new one, we can just discard the new journal.
                (__root/'journals'/newName).delete();
                (__root/'refs'/newName).delete();
                return name;
            } else {
                # In any other case, the journals diverge.
                return newName;
            }
        }
    }

    ## RPC service for pullBranch.  Starts the call off in a new thread.
    void pullBranch(String name, String peer,
                    GeneralCallback[String] callback
                    ) {
        @task(MAWFSInstance inst; String name; String peer;,
              inst.pullBranch(name, peer));
        __pool.submit(MyTask(this, name, peer, callback));
    }
}
