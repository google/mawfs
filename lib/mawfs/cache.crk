# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## The node cache.
module;

import crack.enc.base64 altEncode;
import crack.cont.hashmap HashMap;
import crack.io.fmtutil Indenter;
import crack.io Formatter, FStr, Writer;
import crack.cont.array Array;
import crack.functor Functor1;
import crack.lang cmp, AppendBuffer, AssertionError, Buffer, Exception,
    InvalidArgumentError, InvalidStateError, KeyError, ManagedBuffer,
    WriteBuffer, makeHashVal;
import crack.logger debug, error, info;
import crack.strutil StringArray;
import crack.time Time;
import mawfs.blockstore Entry, Change, Commit, JournalIter, Node, NodeStore,
    MODE_DIR;
import mawfs.chunker RabinChunker, DEFAULT_WINDOW_SIZE;
import mawfs.dllist DLList;

@import crack.ann assert, impl, struct;

String snippet(String content) {
    if (content.size > 10)
        return content.substr(0, 10).getRepr();
    else
        return content.getRepr();
}

const MEG := 1024 * 1024;

# Allow initial blocks of up to one meg.
const DEFAULT_MAX_CONTENT_SIZE := MEG;
const DEFAULT_MAX_CHILDREN := 256;
const DEFAULT_MAX_JOURNAL_SIZE := 16 * MEG;
const DEFAULT_GC_THRESHOLD := 128 * MEG;
const DEFAULT_GC_BOTTOM := 16 * MEG;

const int32
    ## Add child (contains a Node and a name)
    CHANGE_ADD_CHILD = 1,

    ## Delete a child (contains a name).
    CHANGE_DELETE_CHILD = 2,

    ## Write data to node contents (respecting all current rules about file
    ## size, layout etc).  Contains pos and data.
    CHANGE_WRITE = 3,

    ## Resize node contents.  Contains newSize.
    CHANGE_RESIZE = 4;


## Return the size of a node.
uintz _getNodeSize(Node node) {
    class End : VTableBase {}
    class NodeSizer : Node, End {}
    class EntryArraySizer : Array[Entry], End {}
    class Ptr { voidptr p; }
    class PtrSizer : Ptr, End {}
    class EntrySizer : Entry, End {}
    uintz sizeof(End end) { return uintz(end) }
    class StringSizer : String, End {}
    stringSize := sizeof(StringSizer.unsafeCast(null));

    # Add the node size.
    sz := sizeof(NodeSizer.unsafeCast(null));
    if (!(node.contents is null))
        sz += stringSize + node.contents.size;

    # Add the child array.
    if (!(node.children is null)) {
        sz += sizeof(EntryArraySizer.unsafeCast(null));
        sz += sizeof(PtrSizer.unsafeCast(null)) * node.children.count();
        sz += sizeof(EntrySizer.unsafeCast(null)) * node.children.count();
        for (child :in node.children) {
            if (child.hash)
                sz += stringSize + child.hash.size;
            if (child.name)
                sz += stringSize + child.name.size;
        }
    }
    return sz;
}

class Cache {
    NodeStore store;

    uint maxContentSize = DEFAULT_MAX_CONTENT_SIZE;
    uint maxChildren = DEFAULT_MAX_CHILDREN;
    uint maxJournalSize = DEFAULT_MAX_JOURNAL_SIZE;

    ## Cache size where we start doing GC.
    uint gcThreshold = DEFAULT_GC_THRESHOLD;

    ## Cache size where we stop doing GC.
    uint gcBottom = DEFAULT_GC_BOTTOM;

    ## A cached object.
    @abstract class Obj {
        Obj next, prev;

        ## Returns true if the object can be safely released from the cache.
        @abstract bool disposable();

        ## Release the object so it can be freed from memory.
        @abstract void release();

        ## Returns the resident size of the object.
        @abstract uintz getRSize();
    }

    # Node objects indexed by digest.
    HashMap[String, Node] __nodes = {};

    ## Callbacks to be invoked on object creation and destruction.  These are
    ## intended for instrumentation purposes so we can verify that there have
    ## been no memory leaks.
    Functor1[void, Obj] onObjCreate, onObjDestroy;

    ## The least recently used list.  The first object on the list is the
    ## least recently used, the last is the most recently used.  Objects are
    ## removed from the head when we do garbage collection.
    DLList[Obj] __oldest = {};

    ## Adds a new object as the most recently used.
    @final void addObj(Obj obj) {
        @assert(!obj.next && !obj.prev);
        __oldest.append(obj);
    }

    ## Release the object from the LRU queue.
    @final void releaseObj(Obj obj) {
        __oldest.remove(obj);
    }

    ## Bring an object to the end of the least recently used queue.
    @final void touch(Obj obj) {
        if (!(__oldest.tail is obj)) {
            __oldest.remove(obj);
            __oldest.append(obj);
        }
    }

    ## Run garbage collection.  'amount' is the number of bytes that we want
    ## to release.
    void garbageCollect() {
        uintz amount = gcThreshold - gcBottom;
        Obj cur = __oldest.head;
        uintz amountPruned;
        while (cur && amountPruned < amount) {
            if (cur.disposable()) {
                amountPruned += cur.getRSize();
                tmp := cur;
                cur = cur.next;
                tmp.release();
            } else {
                cur = cur.next;
            }
        }
    }

    ## Wrapper for Node so we can include it in the cache.
    class CachedRawNode : Cache.Obj {
        Node node;

        oper init(Node node) : node = node {}

        bool disposable() { return true }
        void release() {} # !MM! we need to remove the item from the cache.
        uintz getRSize() { return _getNodeSize(node) }
    }

    ## Returns the node if it is in the cache, null if not.
    @final Node getNode(String digest) {
        return __nodes.get(digest);
    }

    @final void storeNode(String digest, Node node) {
        if (!__nodes.hasKey(digest)) {
            __nodes[digest] = node;
            __oldest.append(CachedRawNode(node));
        }
    }
}

class Head {

    ## The digest of the last commit.  Changes in the journal are relative to
    ## this.
    String baselineCommit;

    ## The digest of the last change.
    String lastChange;

    ## The name of the branch.  "master" is the default branch.
    String branch;

    oper init(String branch, String baselineCommit) :
        baselineCommit = baselineCommit,
        branch = branch {
    }
}

## Wrapper for the three disjoint elements of a node.  These can vary
## independently.
## - The NodeStore, which can vary if the FSInfo changes (we probably should
##   have had FSInfo wrap the NodeStore).
## - The Cache, which always stays the same.
## - The Head, which can vary with different branches.
class NodeContext {
    NodeStore __store;
    Cache __cache;
    Head __head;

    oper init(NodeStore store, Cache cache, Head head) :
        __store = store,
        __cache = cache,
        __head = head {
    }

    ## Convenience constructor to create a NodeContext complete with a Cache
    ## and Head object.
    oper init(NodeStore store, String branch, String baselineCommit) :
        __store = store,
        __cache = Cache(),
        __head = Head(branch, baselineCommit) {
    }

    @final void addChange(Change change) {
        if (__head.lastChange) {
            change.lastChange = __head.lastChange;
        } else {
            change.commit = __head.baselineCommit;
        }
        __head.lastChange = __store.writeToJournal(__head.branch, change);
    }

    ## Returns true if the caller should commit.
    @final bool shouldCommit() {
        return __store.getJournalSize(__head.branch) >= __cache.maxJournalSize;
    }

    @final String storeNode(Node node) {
        return __store.storeNode(node);
    }

    @final Node getNode(String digest) {
        node := __cache.getNode(digest);
        if (!node) {
            node = __store.getNode(digest);
            __cache.storeNode(digest, node);
        }
        return node;
    }

    @final void clearJournal() {
        __store.deleteJournal(__head.branch);
    }

    @final uint getJournalSize(String branch) {
        return __store.getJournalSize(branch)
    }

    @final JournalIter makeJournalIter() {
        return __store.makeJournalIter(__head.branch);
    }

    @final String makeDigest(Node node) { return __store.makeDigest(node) }

    @final uint getMaxChildren() { return __cache.maxChildren }
    @final void setMaxChildren(uint val) { __cache.maxChildren = val }

    @final uint getMaxJournalSize() { return __cache.maxJournalSize }
    @final void setMaxJournalSize(uint val) { __cache.maxJournalSize = val }

    @final uint getMaxContentSize() { return __cache.maxContentSize }

    @final uint getGCThreshold() { return __cache.gcThreshold }
    @final void setGCThreshold(uint val) { __cache.gcThreshold = val }

    @final uint getGCBottom() { return __cache.gcBottom }

    @final Cache getCache() { return __cache }

    ## Records the digest of a new commit.
    @final void recordCommit(String commit) {
        __head.lastChange = null;
        __head.baselineCommit = commit;
    }

    @final void addObj(Cache.Obj obj) { __cache.addObj(obj) }

    ## Release the object from the LRU queue.
    @final void releaseObj(Cache.Obj obj) { __cache.releaseObj(obj) }

    ## Bring an object to the end of the least recently used queue.
    @final void touch(Cache.Obj obj) { __cache.touch(obj) }

    ## Run garbage collection.  'amount' is the number of bytes that we want
    ## to release.
    @final void garbageCollect() { __cache.garbageCollect() }

    ## Call the "object create" handler.  This should be used when a CacheNode is
    ## constructed.
    @final void onObjCreate(Cache.Obj obj) {
        if (__cache.onObjCreate)
            __cache.onObjCreate(obj);
    }

    ## Call the "Object destroy" handler.
    @final void onObjDestroy(Cache.Obj obj) {
        if (__cache.onObjDestroy)
            __cache.onObjDestroy(obj);
    }

    @final String getBaselineCommit() { return __head.baselineCommit }
    @final String getLastChange() { return __head.lastChange }
    @final void setLastChange(String digest) { __head.lastChange = digest }

    ## Returns the branch name.
    @final String getBranch() { return __head.branch }

    ## Get the head revision of the current branch.
    @final String getHead() { return __store.getHead(__head.branch) }

    ## Stores a new commit and updates the branch head.
    @final void storeCommit(Commit commit) {
        __store.setHead(getBranch(), commitDigest := __store.storeCommit(commit));
        recordCommit(commitDigest);
        info I`commit: digest = $(altEncode(commitDigest)), \
               new root = $(altEncode(commit.root))`;
    }
}

class CachedNode;

## Creates a CachedNode.
CachedNode _makeCachedNode(CachedNode parent, NodeContext ctx, String digest);

## Wraps a Node object with caching functionality.
class CachedNode : Cache.Obj {
    NodeContext __ctx;

    String digest;
    Node node;

    ## Indicates that a node has been changed in memory and in the transaction
    ## log but needs to be committed.  A dirty node is assumed to have an
    ## invalid digest.  Likewise, a non-dirty node is assumed to have a valid
    ## digest.  All nodes should either be loaded from the block store (in
    ## which case, they have a valid digest) or created as part of an
    ## operation (in which case they should have no digest and be dirty).
    bool dirty;

    ## The parent node (the directory if this is a directory or top-level
    ## file node, an intermediate node for anything else).  Note that this
    ## introduces a reference cycle, so you need to call release() on a node
    ## to break this cycle (and also to remove the node from the LRU queue in
    ## the cache).
    CachedNode parent;

    class VerifyReport;
    VerifyReport verify();

    ## Gets the node's mode.
    @final int getMode() {
        return node.mode;
    }

    @final bool isDir() {
        return node.mode & MODE_DIR;
    }

    @final uint64 getSize();

    ## Manages caching for an Entry record and the associated child node.
    ##
    ## Invariants:
    ## - 1:1 relationship between CachedEntry and its parent.  The parent must
    ##   have the cached entry in its children list and the entry must only be
    ##   in one parent's children list.  This must be enforced by CachedNode.
    class CachedEntry {
        Entry entry;
        NodeContext __ctx;
        CachedNode node;
        CachedNode __parent;

        oper init(NodeContext ctx, Entry entry, CachedNode parent) :
            entry = entry,
            __ctx = ctx,
            __parent = parent {
        }

        oper init(Entry entry, CachedNode node, CachedNode parent) :
            entry = entry,
            node = node,
            __parent = parent {

            # We shouldn't really need the cache if we've already got the
            # node, but this gives us a clean invariant.
            __ctx = node.__ctx;
        }

        @final String getName() {
            return entry.name;
        }

        @final String getDigest() {
            return entry.hash;
        }

        @final void setDigest(String digest) {
            entry.hash = digest;
        }

        @final uint64 getSize() {
            return uint64(entry.size);
        }

        ## Returns the node referenced by this child object.
        @final CachedNode getNode() {
            # Lazy load the node.
            if (!node) {
                if (!entry.hash)
                    throw InvalidStateError(
                        FStr() `No hash or node for $(entry.name)`
                    );
                node = _makeCachedNode(__parent, __ctx, entry.hash);
            }
            return node;
        }

        @final int getMode() {
            return getNode().getMode();
        }

        @final CachedNode getParent() { return __parent }
        @final void setParent(CachedNode parent) {
            __parent = parent;
            if (node)
                node.parent = parent;
        }

        @final void setCachedNode(CachedNode node) {
            this.node = node;
            entry.size = node.getSize();
            entry.hash = null;
        }

        ## Set the size in the entry to the size of the referenced node.
        @final void fixSize() {
            entry.size = getNode().getSize();
        }

        ## Release the node (if any) allowing it to be GCed.
        @final void releaseNode() {
            if (node) {
                node.release();
                node = null;
            }
        }

        void formatTo(Formatter out) {
            indent := Indenter.wrap(out);
            dig := getDigest();
            String digest;
            if (dig)
                digest := altEncode(dig);
            name := getName();
            if (name is null)
                out `-   `;
            else
                out I`$(name.getRepr()):\n`;
            ++indent;
            out I`digest: $(digest ? altEncode(digest) : 'null')
                  size: $(getSize())
                  node: `;
            out `$(node)\n`;
            --indent;
        }
    }

    ## A list of children sorted by name.  Retrieval/insertion by name is
    ## supported.
    ## node.children must exist for this to be created.
    class __ChildArray {

        # Underlying representation (stored in the Node).
        Array[Entry] __rep;

        # Cached entries.
        Array[CachedEntry] __cached;

        oper init(Array[Entry] rep) :
            __rep = rep,
            __cached(rep.count(), null) {
        }

        ## Recursive helper for __findIndex(String).
        @final int __findIndex(String name, uint start, uint end) {

            if (!__cached.count())
                return -1;

            uint midpoint = (end - start) / 2 + start;
            if (midpoint == start) {
                comparison := cmp(name, __cached[midpoint].getName());
                if (comparison == 0)
                    return start;
                else if (comparison < 0)
                    return -(start + 1);
                else
                    return -(end + 1);
            }

            if (name == __cached[midpoint].getName())
                return midpoint;

            if (name < __cached[midpoint].getName())
                return __findIndex(name, start, midpoint);
            else
                return __findIndex(name, midpoint, end);
        }

        ## Find the index of the child with the given name.  If there is no
        ## match in the array, returns the
        ## negative index + 1 of where the element would be (so if it belonged
        ## at index 0, we would return -1).  Returns the index of the element
        ## if it was found as an ordinary positive integer.
        @final int findIndex(String name) {
            return __findIndex(name, 0, __cached.count());
        }

        ## Return the entry identified by the name, null if it doesn't exist.
        @final CachedEntry get(String name) {
            i := __findIndex(name, 0, __cached.count());
            if (i < 0)
                return null;
            else
                return __cached[i];
        }

        ## Adds a child to the array by order of name.
        @final void add(CachedEntry entry) {
            i := findIndex(entry.getName());
            if (i >= 0) {
                __cached[i] = entry;
                __rep[i] = entry.entry;
            } else {
                __cached.insert(-i - 1, entry);
                __rep.insert(-i - 1, entry.entry);
            }
        }

        @final bool delete(String name) {
            i := findIndex(name);
            if (i >= 0) {
                __cached.delete(i);
                __rep.delete(i);
                return true;
            } else {
                return false;
            }
        }

        ## Deletes a child by index.
        @final void delete(uint index) {
            __cached.delete(index);
            __rep.delete(index);
        }

        @final void append(CachedEntry entry) {
            __cached.append(entry);
            __rep.append(entry.entry);
        }

        @final void insert(uint index, CachedEntry entry) {
            __cached.insert(index, entry);
            __rep.insert(index, entry.entry);
        }

        @final uint count() {
            return __cached.count();
        }

        @final CachedEntry oper [](int index) {
            return __cached[index];
        }

        @final CachedEntry oper []=(int index, CachedEntry entry) {
            return __cached[index] = entry;
        }

        @final Array[CachedEntry].ArrayIter iter() { return __cached.iter() }

        ## Returns the underlying array of entries.  Caller must not modify
        ## its contents directly.
        @final Array[Entry] getRep() { return __rep }

        void formatTo(Formatter out) {
            out `CachedEntries![\n`;
            for (child :in __cached)
                out `$child\n`;
            out `]`;
        }

        bool isTrue() { return __cached }
    }

    # A sparse-array version of Node.children.  These get filled in as they
    # are accessed or when __populateChildren() is called.
    __ChildArray __children;

    ## Moves the node to the back of the least-recently-used queue.  Should
    ## be called all public and all recursive functions that references the
    ## node.
    @final void __touched() { __ctx.touch(this) }

    ## digest should be null for a new node.
    oper init(NodeContext cache, String digest, Node node) :
        __ctx = cache,
        digest = digest,
        node = node,
        dirty = !digest {

        __ctx.addObj(this);
        __ctx.onObjCreate(this);
    }

    oper del() {
        __ctx.onObjDestroy(this);
    }

    ## Allocate __children array to mirror the values in node.children.
    ## Creates node.children if it doesn't exist.
    @final void __makeChildren() {
        # First make sure we have node.children.
        if (!node.children)
            node.children = Array[Entry]();

        # Create an array of children to mirror that of node.children,
        # initialize all elements to null.
        __children = __ChildArray(node.children);

        __touched();
    }

    ## Returns true if the object is disposable, meaning that it doesn't need
    ## to be memory resident.  A CachedNode is disposable if it is not dirty
    ## and has no children.
    bool disposable() {
        if (dirty) {
            return false;
        }

        # Non-dirty node without children is disposable.
        if (!__children)
            return true;

        for (child :in __children) {
            if (child.node) {
                return false;
            }
        }

        return true;
    }

    ## Release the cached node from the cache, allowing it to be deleted.
    void release() {

        # Due to a bug in crack up to 0.13.1, we can end up releasing this
        # object in the releaseObj() method below (nothing guarantees that a
        # parameter remains in existence for the life of the function).
        # The assignment to temporary keeps 'this' from being gc'ed.
        temp := this;

        # Remove the node from its parent.
        if (parent && parent.__children) {
            for (child :in parent.__children) {
                if (child.node is this) {
                    child.node = null;
                    break;
                }
            }
        }

        __ctx.releaseObj(this);
        if (__children) {
            # Releasing the children breaks all cyclic links to the parent.
            for (child :in __children)
                child.releaseNode();
            __children = null;
        }
    }

    ## Returns the "resident size" of the node.  This is an approximation of
    ## the memory size of the node and all of its descendents that are loaded
    ## into memory.
    uintz getRSize() {
        # TODO: Implement sizeof in crack, convert to real sizeof.  This sucks.
        class End : VTableBase {}
        class Sizer : CachedNode, End {
            oper init() : CachedNode(null, null, null) {}
        }
        class StringSizer : String, End {}
        class ChildArraySizer : __ChildArray, End {
            oper init() : __ChildArray(null) {}
        }
        class EntryArraySizer : Array[Entry], End {}
        class Ptr { voidptr p; }
        class PtrSizer : Ptr, End {}
        class CachedEntrySizer : CachedEntry, End {
            oper init() : CachedEntry(null, null, null) {}
        }
        uintz sizeof(End end) { return uintz(end) }
        stringSize := sizeof(StringSizer.unsafeCast(null));
        ptrSize := sizeof(PtrSizer.unsafeCast(null));
        sz := sizeof(Sizer.unsafeCast(null));
        if (digest)
            sz += stringSize + digest.size;

        sz += _getNodeSize(node);

        if (!(__children is null)) {
            sz += sizeof(ChildArraySizer.unsafeCast(null));
            sz += ptrSize * __children.count();
            for (child :in __children) {
                if (child) {
                    sz += sizeof(CachedEntrySizer.unsafeCast(null)) *
                          __children.count();
                    if (child.node)
                        sz += child.node.getRSize();
                }
            }
        }

        return sz;
    }

    ## Allocate the __children scaffold and populate with the child entries
    ## from the node.
    ## If createEmpty is true, create the scaffold even if node.children is
    ## null, and also create an empty node.children.
    ## If createEmpty is false and children is null or empty, do nothing and
    ## return false.
    ## Return true if the scaffold exists at the end of the method, false if
    ## not.
    @final bool __populateChildren(bool createEmpty) {
        if (!(__children is null))
            return true;
        if (node.children || createEmpty) {
            if (node.children is null)
                node.children = Array[Entry]();
            __makeChildren();
            for (iter :on node.children)
                __children[iter.index] =
                    CachedEntry(__ctx, iter.elem(), this);
            return true;
        } else {
            return false;
        }
    }

    CachedEntry __getChildEntry(uint index) {
        CachedEntry cachedEntry;
        if (!__populateChildren(false))
            return null;

        cachedEntry = __children[index];
        if (!cachedEntry) {
            entry := node.children[index];

            node := _makeCachedNode(this, __ctx, entry.hash);
            if (!node) {
                error `Unable to load node $(entry.hash)`;
                return null;
            }

            cachedEntry = __children[index] = CachedEntry(entry, node, this);
        }

        return cachedEntry;
    }

    ## Get a child by its index.  Throw IndexError if the index is out of
    ## range.  Return null if we are unable to retrieve the node.
    CachedNode getChild(uint index) {
        __touched();
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getNode();
    }

    ## Returns the name of a child.
    String getChildName(uint index) {
        __touched();
        cachedEntry := __getChildEntry(index);
        return cachedEntry.getName();
    }

    ## Get the child with the given name.  Returns null if there is no such
    ## child.
    @final CachedNode getChild(String name) {
        __touched();
        if (!__populateChildren(false))
            return null;
        child := __children.get(name);
        if (!child)
            return null;
        else
            return child.getNode();
    }


    ## Returns the total size of the node.
    @final uint64 getSize() {
        __touched();
        return node.size;
    }

    @final String getContents() {
        __touched();
        if (!(node.contents is null)) {
            return node.contents;
        } else if (node.children != null) {
            AppendBuffer buf = {getSize()};
            __populateChildren(false);
            for (child :in __children)
                buf.extend(child.getNode().getContents());
            return String(buf, true);
        } else {
            return null;
        }

    }

    ## Returns all ccontent leaf nodes of a given node.  This method is really
    ## just for testing/debugging purposes.
    @final StringArray getChunks() {
        __touched();
        if (!(node.contents is null))
            return StringArray![node.contents];

        @assert(__populateChildren(true));
        StringArray result = {};
        for (child :in __children)
            result.extend(child.getNode().getChunks());
        return result;
    }

    ## Returns true if this is a content node (a leaf).
    @final bool __isContentNode() { return node.contents }

    ## Returns the CachedEntry for the child wrapping the node.  Returns
    ## 'null' if undefined.
    @final CachedEntry __getChildEntry(CachedNode node) {
        for (child :in __children) {
            if (child.node is node)
                return child;
        }

        return null;
    }

    ## Mark the node as dirty and do the same for all parent nodes.
    void __markDirty() {
        __touched();

        # Find the child in the parent and invalidate all instances.
        if (parent) {
            myEntry := parent.__getChildEntry(this);
            myEntry.setDigest(null);
        }

        dirty = true;
        if (parent) parent.__markDirty();
    }

    void __makePath(Array[int32] path) {
        # Even though this function is recursive, we don't need to touch it -
        # it's upward recursive so the node should already have been touched
        # and we don't want to force it to most recently used like
        # __markDirty().
        if (!parent)
            return;

        # Lookup the index of the child (it is always safe to assume
        # __children has been populated for a parent).
        uint i = 0;
        for (child :in parent.__children) {

            # We use .node here instead of getNode(), if the node hasn't been
            # lazy loaded it can't be this one, and we don't want to lazy load
            # any new nodes.
            if (child.node is this)
                break;
            ++i;
        }

        parent.__makePath(path);
        path.append(int32(i));
    }

    CachedNode getRoot();
    String commit();
    void garbageCollect();

    ## Commit the entire tree and record a commit object.
    void commitTree() {
        # We don't need to __touched(), we're about to call commit().
        info `committing on branch $(__ctx.getBranch()).`;
        newRootDigest := getRoot().commit();
        Commit commit = {};
        commit.root = newRootDigest;
        commit.parent_append(__ctx.getHead());
        __ctx.storeCommit(commit);
        size := getSize();

        # After commit is the best time to run garbage collection because
        # there are no dirty nodes.
        garbageCollect();
    }

    ## Record a change in the journal for this node or for the appropriate
    ## parent node if this node doesn't have a digest yet.
    void __recordChange(Change change) {
        change.path = Array[int32]();
        __makePath(change.path);
        __ctx.addChange(change);
        if (__ctx.shouldCommit())
            commitTree();
    }

    ## Internal add child method, which does everything but create a change
    ## record.
    CachedNode __addChild(String name, CachedNode child) {
        child.parent = this;

        CachedEntry entry = {Entry(), child, this};
        entry.entry.name = name;

        __populateChildren(true);

        # Add the child.
        __children.add(entry);

        # Mark the node and the entire ancestor chain as dirty.
        __markDirty();

        return child;
    }

    ## Add a new child which is a CachedNode.
    ## You should use this for adding children with cached descendants.
    void addChild(String name, CachedNode child) {
        __touched();
        __addChild(name, child);

        # Record the change in the journal.
        change := Change();
        change.type = CHANGE_ADD_CHILD;
        change.name = name;
        change.node = child.node;
        __recordChange(change);
    }

    ## Add a new child node with the specified name.
    CachedNode addChild(String name, Node node) {
        # we don't call __touched() because this addChild() does.
        addChild(name, child := CachedNode(__ctx, null, node));
        return child;
    }

    ## Delete the named child and return true, or return false if the child
    ## doesn't exist.
    bool deleteChild(String name) {
        # We don't __touched() because the object is going to be marked dirty.
        if (!__populateChildren(true))
            return false;
        if (!__children.delete(name))
            return false;

        # Record the change.
        change := Change();
        change.type = CHANGE_DELETE_CHILD;
        change.name = name;
        __recordChange(change);
        __markDirty();

        return true;
    }

    ## Returns the number of children in the node.
    uint getChildCount() {
        __touched();
        return node.children ? node.children.count() : 0;
    }

    ## Returns the root of the cached filesystem.
    CachedNode getRoot() {
        # We don't call __touched() because in this case, we're not interested
        # in the object.
        if (!parent)
            return this;
        else
            return parent.getRoot();
    }

    ## Returns the node context object for the node.
    NodeContext getContext() {
        # We don't __touched() because we're not interested in the object.
        return __ctx;
    }

    ## Make a new unnamed entry for the node parented by 'this'.
    CachedEntry __makeUnnamedEntry(CachedNode node, CachedNode parent) {
        entry := Entry();
        entry.size = node.getSize();
        cachedEntry := CachedEntry(__ctx, entry, this);
        cachedEntry.node = node;
        cachedEntry.setParent(parent);
        return cachedEntry;
    }

    ## Split the node if it exceeds the maximum number of children.  If the
    ## node is split, return the new node full of the higher children.
    ## Otherwise return null.
    CachedNode __maybeSplit() {
        if (__children.count() <= __ctx.getMaxChildren())
            return null;

        # Number of nodes in the new first child.
        newSize := __children.count() / 2;

        # Make a copy of the children and reset.
        children := __children;
        __children = null;
        node.children = null;
        node.size = 0;
        __populateChildren(true);

        # Copy the lower children to the receiver.
        int i;
        for (; i < newSize; ++i) {
            __children.append(children[i]);
            node.size += children[i].getSize();
        }

        # Create a new node and copy the higher children.
        CachedNode newNode = {__ctx, null, Node()};
        newNode.__populateChildren(true);
        for (; i < children.count(); ++i) {
            newNode.__children.append(child := children[i]);
            child.setParent(newNode);
            newNode.node.size += children[i].getSize();
        }

        return newNode;
    }

    ## Append a new child to the end of the tree.  If the insertion of the
    ## child results in an intermediate node being split, return the new
    ## intermediate node.  Otherwise return null.
    ## 'child' must be a content node.
    CachedNode __appendChild(CachedNode child) {
        __touched();
        # XXX why does this not mark the node as dirty?
        if (!__populateChildren(false)) {
            # Content node.  Just return the new child as the extra node,
            # parent will append.
            return child;
        } else if (!__children ||
                   __children[0].getNode().node.children is null) {
            # The children of this node are content nodes, append here.
            # (we do the check for !__children because it's possible to end up
            # in an intermediate state with no children.  grrrr... broken
            # invariants)
            __children.append(ent := __makeUnnamedEntry(child, this));
            node.size += ent.getSize();
            @assert(ent.getParent() is this);
            return __maybeSplit();
        } else {
            node.size += child.node.size;

            # Recurse to last child, update the size in the entry.
            lastChild := __children[-1];
            extra := lastChild.getNode().__appendChild(child);
            if (extra) {
                lastChild.fixSize();
                __children.append(ent := __makeUnnamedEntry(extra, this));
                @assert(ent.getParent() is this);
                return __maybeSplit();
            } else {
                # If we added to the last child without a split, we need to
                # update the entry's size.
                lastChild.entry.size += child.node.size;
            }
        }

        return null;
    }

    ## Reset the node object associated with the cached node and also reset
    ## all fields dependent on the node and mark the cached node as dirty.
    void __resetNode(Node node) {
        this.node = node;
        __children = null;
        digest = null;
        dirty = true;
    }

    Node __makeNode(String contents) {
        newNode := Node();
        newNode.contents = contents;
        newNode.size = contents.size;
        return newNode;
    }

    ## Steal and reparent the child array from 'other'.
    void __stealChildren(CachedNode other) {
        # XXX why does this not mark the node as dirty?
        # Don't modify other.node - in some cases we steal the entire node as
        # well as its children.
        __children = other.__children;
        node.children = other.__children.getRep();
        node.size = other.node.size;
        for (child :in __children)
            child.setParent(this);
        other.__children = null;
    }

    ## Add a new tier to a top-level node by creating a new child node and
    ## moving all of the children to it.
    void __addTier() {
        @assert(__populateChildren(false));

        # Create a new node to hold the existing children.
        firstChild := CachedNode(__ctx, null, Node());
        firstChild.__stealChildren(this);

        # Create a new node with a child array.
        __resetNode(Node());
        __populateChildren(true);

        __children.append(ent := __makeUnnamedEntry(firstChild, this));
        node.size += ent.getSize();
        firstChild.parent = this;
    }

    ## Append a new content string to the end of the tree.
    void append(String contents) {
        # We don't __touched() because __appendChild() does.
        newNode := __makeNode(contents);
        cached := CachedNode(__ctx, null, newNode);
        extra := __appendChild(cached);
        if (extra) {
            # If this is a content node, we need to convert it to an
            # intermediate node.
            if (node.children is null) {
                CachedNode firstChild;
                if (node.contents != null)
                    firstChild = CachedNode(__ctx, null, node);

                # Create a new node with a child array.
                __resetNode(Node());
                __populateChildren(true);

                if (firstChild) {
                    __children.append(ent := __makeUnnamedEntry(firstChild,
                                                                this));
                    node.size += ent.getSize();
                }
            } else {
                # The current node is the top-level intermediate node and it
                # has been split.
                __addTier();
            }
            __children.append(ent := __makeUnnamedEntry(extra, this));
            node.size += ent.getSize();
            __markDirty();
            # XXX we need to "maybeSplit" after this and then do the same
            # switch we did above.
        }
    }

    ## Write the beginning of the chunk containing 'pos' up to 'pos'.
    ## Returns the
    uint64 __writeChunkPrefix(Writer out, uint64 pos) {
        __touched();

        # If we've got contents, write the beginning of the contents.
        if (node.contents) {
            out.write(Buffer(node.contents.buffer, uintz(pos)));
            return 0;
        }

        # Otherwise find the child containing the position.
        uint64 base;
        for (child :in __children) {
            if (pos < base + child.getSize()) {
                return base +
                       child.getNode().__writeChunkPrefix(out, pos - base);
            }

            base += child.getSize();
        }

        # We shouldn't get here, the position begins after all children.
        return base;
    }

    ## Write the end of the chunk containing pos (from pos to the end of the
    ## chunk).
    ## Returns the position of the end of the chunk.  If the return value is
    ## greater than the size of the chunk, the caller must also write the next
    ## child.
    uint64 __writeChunkSuffix(Writer out, uint64 pos) {
        __touched();
        # If the specified position is out of range, there's nothing to write.
        if (pos >= node.size)
            return node.size;

        if (node.contents) {
            out.write(Buffer(node.contents.buffer + pos,
                             node.contents.size - pos
                             )
                      );
            # If we're going to overwrite the chunking window, we need to
            # return a signal to write the next chunk.
            if (node.contents.size - pos < DEFAULT_WINDOW_SIZE) {
                return node.contents.size + 1;
            }
            return node.contents.size;
        }

        uint64 base, continueToNext;
        for (child :in __children) {
            childSize := child.getSize();
            if (pos < base + childSize) {
                end := child.getNode().__writeChunkSuffix(out, pos - base);
                if (end <= childSize)
                    return base + end;

                # The end exceeds the size of the child - continue to the next
                # child.
                pos = base + childSize;
                continueToNext = 1;
            }
            base += childSize;
        }

        # We can get here if 'pos' is greater than the child -- or if we need
        # to also add the next child because we may have changed the
        # fingerprint.
        return base + continueToNext;
    }

    ## Returns the children array, throwing an AssertionError if this is not
    ## an inner node.
    @final __ChildArray __getChildren() {
        @assert(__populateChildren(false));
        return __children;
    }

    ## Merge the child at the specified index with its nearest sibling.  The
    ## child must have exactly one child of its own which will be inserted or
    ## appended into the next or previous sibling.
    ##
    ## Returns true if we merged with the next child, false if we merged with
    ## the previous child.
    ##
    ## This is only public for tests.
    @final bool mergeChild(uint index) {
        bool mergeWithNext;
        node := __children[index].getNode();
        @assert(node.getChildCount() == 1);
        entry := node.__children[0];

        if (index == 0 ||
            index < __children.count() - 1 &&
             __children[index + 1].getNode().getChildCount() <
             __children[index - 1].getNode().getChildCount()
            ) {
            # Merge with the next child.

            nextChildEntry := __children[index + 1];
            nextChild := nextChildEntry.getNode();
            nextChild.__getChildren().insert(0, entry);
            nextChild.node.size += entry.getSize();
            nextChildEntry.fixSize();

            # Reparent the entry and remove it from its parent (we we can just
            # set __children to null since its an only child).
            entry.setParent(nextChild);
            node.__children = null;

            # Remove the child.
            __children.delete(index);

            # If the entry itself only has one child, merge recursively.
            if ((n := entry.getNode()).__populateChildren(false) &&
                 n.__getChildren().count() == 1
                )
                nextChild.mergeChild(0);

            # Release the node now that we're done with it.
            node.release();

            # Split the new entry.
            newChild := nextChild.__maybeSplit();
            if (newChild) {
                nextChildEntry.fixSize();
                __children.insert(index + 1,
                                  __makeUnnamedEntry(newChild, this)
                                  );
            }

            return true;
        } else {
            # Merge with the previous child.

            prevChildEntry := __children[index - 1];
            prevChild := prevChildEntry.getNode();
            prevChild.__getChildren().append(entry);
            prevChild.node.size += entry.getSize();
            prevChildEntry.fixSize();

            # Reparent the entry and remove it from its parent (we we can just
            # set __children to null since its an only child).
            entry.setParent(prevChild);
            node.__children = null;

            # Remove the child.
            __children.delete(index);

            # If the entry itself only has one child, merge recursively.
            if ((n := entry.getNode()).__populateChildren(false) &&
                 n.__getChildren().count() == 1
                )
                prevChild.mergeChild(prevChild.__getChildren().count() - 1);

            # Release the node now that we're done with it.
            node.release();

            # Split the new entry.
            newChild := prevChild.__maybeSplit();
            if (newChild) {
                prevChildEntry.fixSize();
                __children.insert(index,
                                  __makeUnnamedEntry(newChild, this)
                                  );
            }

            return false;
        }
    }

    ## Returns the size of the child deleted, returns the negative size if the
    ## child is an intermediate node with only one child of its own after the
    ## delete.
    int64 __deleteNode(uint64 pos) {
        @assert(__populateChildren(false));
        uint index;
        for (child :in __children) {
            int64 childSize;
            if (pos < child.getSize()) {
                # Delete this node or one of its children.
                if (child.getNode().__isContentNode()) {
                    # The child is a content node.  Remove it.
                    childSize = int64(child.getSize());
                    __children.delete(index);
                    child.node.release();
                } else {
                    # The child is an intermediate node, have it remove the
                    # appropriate content node.
                    childSize = child.getNode().__deleteNode(pos);
                    if (childSize < 0) {
                        # The child now has only one child of its own.
                        mergeChild(index);
                        childSize = -childSize;
                    }

                    child.entry.size -= uint64(childSize);
                }

                node.size -= uint64(childSize);
                return (__children.count() < 2) ? -childSize : childSize;
            }

            pos -= child.getSize();
            ++index;
        }

        # If we get here, the caller has specified a position that is out of
        # bounds.
        @assert(false);
        return 0;
    }

    ## Delete the leaf node at the position.  Call this on the top-level node
    ## of a file.
    ## Returns the size of the deleted node.
    int64 deleteNode(uint64 pos) {
        size := __deleteNode(pos);

        # If we have one child left, collapse the level.  We don't need to
        # call __populateChildren, __deleteNode() should have done that for us.
        if (__children.count() == 1) {
            cachedNode := __children[0].getNode();
            node = cachedNode.node;
            __stealChildren(cachedNode);
            cachedNode.release();
            if (parent) {
                entry := parent.__getChildEntry(this);
                entry.setCachedNode(this);
            }
        }

        __markDirty();
        return size;
    }

    ## Delete a span from the tree.  Returns true of the node now has a single
    ## child and should be merged.
    bool __deleteSpan(uint64 start, uint64 end) {
        if (node.contents) {
            if (start > node.contents.size) {
                return false;
            } else if (start < node.contents.size && end < node.contents.size) {
                node.contents = node.contents.substr(0, start) +
                                node.contents.substr(end);
            } else {
                # Delete everything after start.
                node.contents = node.contents.substr(0, start);
            }
            node.size = node.contents.size;
            dirty = true;
            return false;
        }

        # This is an inner node.
        @assert(__populateChildren(false));
        for (int i; i < __children.count() && end; ++i) {
            child := __children[i];
            childSize := child.getSize();

            if (start == 0 && end >= childSize) {
                # The entire child node must be deleted.
                __children.delete(i);
                node.size -= childSize;
                dirty = true;
                --i;
                end -= childSize;
                child.releaseNode();
            } else if (start < childSize) {
                # Part of the child must be deleted.
                mustMerge := child.getNode().__deleteSpan(start, end);
                child.fixSize();
                amtDeleted := childSize - child.getSize();
                node.size -= amtDeleted;
                dirty = true;
                spanSize := end - start;
                start = 0;

                adjustedSpan := false;

                # Before merging we have to verify that we have more than one
                # child because this algorithm can leave us with just one
                # remaining child.  We account for this in the merge - if
                # we're merging a child that has only one child we recursively
                # merge it.
                if (mustMerge && __children.count() > 1) {
                    if (mergeChild(i)) {
                        # We merged with the _next_ child, so we have to adjust
                        # the span.
                        start = child.getSize();
                        end = start + spanSize - amtDeleted;
                        adjustedSpan = true;
                    }
                    --i;
                }

                if (!adjustedSpan) {
                    # No merge or merged with previous.  Adjust the start and
                    # end for the next child.
                    start = 0;
                    if (end < childSize)
                        break;
                    else
                        end -= childSize
                }
            } else {
                start -= childSize;
                end -= childSize;
            }
        }

        return __children.count() == 1;
    }

    ## Delete a range of bytes from the file.  This should only be applied to
    ## the toplevel node of a file.
    void deleteSpan(uint64 start, uint64 end) {
        if (__deleteSpan(start, end)) {
            # We need to collapse a level.
            firstChild := __children[0].getNode();
            if (firstChild.node.contents) {
                # The child is a content node, steal its contents.
                node.contents = firstChild.node.contents;
                node.size = node.contents.size;
                __children = null;
                node.children = null;
            } else {
                __stealChildren(firstChild);
            }

            firstChild.release();
        }

        __markDirty();
    }

    CachedNode __insertChild(uint64 pos, CachedNode node) {
        __touched();
        # This only works on inner nodes.
        @assert(__populateChildren(false));
        @assert(pos <= this.node.size);
        int i;

        dirty = true;

        if (!__children) {
            # Deal with the case of an empty node. This can currently happen
            # only in the case where the entire contents of a toplevel node
            # are being replaced.  XXX I don't think this can happen in this
            # case, even.
            __children.append(__makeUnnamedEntry(node, this));
        } else if (__children[0].getNode().__isContentNode()) {
            # The children are content nodes, directly insert.

            # Shortcut if we're inserting at the end.
            if (pos == this.node.size) {
                __children.append(__makeUnnamedEntry(node, this));
            } else {
                # Find the child to insert after.
                for (child :in __children) {
                    if (!pos) {
                        __children.insert(i, __makeUnnamedEntry(node, this));
                        break;
                    } else {
                        @assert(pos >= child.getSize());
                    }

                    pos -= child.getSize();
                    ++i;
                }
            }
        } else {
            # Inner node, recurse.

            # See if we're inserting at the end.
            if (pos == this.node.size) {
                child := __children[-1];
                extra := child.getNode().__insertChild(child.getSize(), node);
                child.fixSize();
                if (extra)
                    __children.append(__makeUnnamedEntry(extra, this));
            } else {
                int i = 1;
                for (child :in __children) {
                    if (pos < child.getSize()) {
                        extra := child.getNode().__insertChild(pos, node);
                        child.fixSize();
                        if (extra) {
                            __children.insert(i, __makeUnnamedEntry(extra, this));
                        }
                        break;
                    }

                    pos -= child.getSize();
                    ++i;
                }
            }
        }

        this.node.size += node.getSize();
        return __maybeSplit();
    }

    void __insert(uint64 pos, String contents) {
        newNode := CachedNode(__ctx, null, __makeNode(contents));

        extra := __insertChild(pos, newNode);
        if (extra) {
            __addTier();
            __children.append(__makeUnnamedEntry(extra, this));
            node.size += extra.getSize();
        }
    }

    ## Write the last chunk to out, return the start position of the chunk.
    uint64 __writeLastChunk(Writer out) {
        if (__isContentNode()) {
            out.write(node.contents);
            return 0;
        } else {
            @assert(__populateChildren(false));
            uint64 start;
            lastChild := __children[-1];
            offset := lastChild.getNode().__writeLastChunk(out);
            return offset + getSize() - lastChild.getSize();
        }
    }

    ## Write data to a file at 'pos'.
    ##
    ## This needs to be applied to the top node of the file.
    void __write(uint64 pos, Buffer data) {
        class ListWriter @impl Writer {
            StringArray items = {};

            void write(Buffer data) {
                items.append(String(data));
            }
        }

        ListWriter writer = {};
        RabinChunker chunker = {writer};

        if (node.children is null && !node.contents) {

            # Empty node.

            # We don't have to mix in with anything.
            chunker.writeZeros(pos - getSize());
            chunker.write(data);
            chunker.flush();

            # Just append all of the items to the tree.
            for (item :in writer.items)
                append(item);

        } else if (!(node.contents is null)) {

            # This is a node with contents.

            # Copy the existing contents until we get to 'pos'.
            if (pos) {
                if (pos > node.contents.size) {
                    chunker.write(node.contents);
                    chunker.writeZeros(pos - node.contents.size);
                } else {
                    chunker.write(node.contents.substr(0, pos));
                }
            }

            # Write the data.
            chunker.write(data);

            # If there's content after the data, write it.
            end := pos + data.size;
            if (end < node.contents.size)
                chunker.write(Buffer(node.contents.buffer + uintz(end),
                                     node.contents.size - end
                                     )
                              );

            chunker.flush();

            # Replace the existing contents with the new items.
            node.contents = null;
            for (item :in writer.items)
                append(item);

        # All remaining cases are nodes with children.

        } else if (pos >= getSize()) {
            # We're writing after the end, just append.

            # Start with the last chunk (we will likely need to extend it).
            start := __writeLastChunk(chunker);

            # Write the new data.
            chunker.writeZeros(pos - getSize());
            chunker.write(data);
            chunker.flush();

            # Remove the last chunk. Note:  This can break the "no empty inner
            # nodes" invariant in cases where a node has a single child (which
            # also breaks an invariant...)
            __deleteSpan(start, getSize());

            for (item :in writer.items)
                append(item);
        } else {
            # Write beginning in the middle of a node with children.

            # Write the beginning of the first existing chunk.
            start := __writeChunkPrefix(chunker, pos);

            # Write the data.
            chunker.write(data);

            # Find the node containing the end position (if any).
            end := __writeChunkSuffix(chunker, pos + data.size);

            # If we get an end position greater than the size, it just means
            # that we would have to write the next chunk.  Since there is no
            # next chunk, just adjust the size.
            if (end > getSize())
                end = getSize();

            chunker.flush();

            # Replace all of the chunks in the span.
            delta := end - start;  orgSize := getContents().size;
            __deleteSpan(start, end);
            @assert(getContents().size == orgSize - delta);
            pos = start;
            for (item :in writer.items) {
                __insert(pos, item);
                pos += item.size;
            }
        }

        __markDirty();
    }

    void write(uint64 pos, Buffer data) {
        __write(pos, data);

        change := Change();
        change.type = CHANGE_WRITE;
        @assert(pos < 0x100000000);
        change.pos = pos;
        change.data = String(data);
        __recordChange(change);
    }

    void __resize(uint64 newSize) {
        if (newSize == node.size)
            return;
        else if (newSize < node.size)
            deleteSpan(newSize, node.size);
        else
            __write(newSize, '');
    }

    ## Resize contents to the specified size.  Truncate the node if less than
    ## the existing size, pad with zeroes if greater than the existing size.
    ## Returns false if unable to accomodate.
    bool resize(uint64 newSize) {
        __resize(newSize);

        change := Change();
        change.type = CHANGE_RESIZE;
        change.newSize = newSize;
        __recordChange(change);

        return true;
    }

    ## Commit all outstanding changes in the tree.  Returns the new digest.
    String commit() {
        # If our digest is up to date, we don't need to do anything.
        if (!dirty)
            return digest;

        if (__populateChildren(false)) {
            # Commit all dirty children and reconstruct the child list for the
            # underlying node.
            for (child :in __children) {
                # If there's no child node, it's safe to ignore this child
                # because it can't be dirty.
                if (!child.node) {
                    @assert(child.getDigest());
                    continue;
                }

                dig := child.node.commit();
                curDigest := child.getDigest();
                if (!curDigest || curDigest != dig)
                    child.setDigest(dig);
            }
        }

        # Commit the node itself and clear the journal.
        orgDigest := digest;
        if (__children) {
            for (child :in __children) {
                if (!child.entry.hash)
                    throw AssertionError(
                        FStr() `Invalid hash for $(child.getName())`
                    );
            }
        }

        digest = __ctx.storeNode(node);
        dirty = false;
        __ctx.clearJournal();

        return digest;
    }

    ## Utility class for formatting a Change message.  This is useful for
    ## debugging problems during journal replay.
    class ChangeFormatter {
        CachedNode node;
        Change change;
        oper init(CachedNode node, Change change) :
            node = node,
            change = change {
        }

        void formatChange(Formatter out) {
            if (change.type == CHANGE_ADD_CHILD) {
                out ` add child $(change.name)`;
            } else if (change.type == CHANGE_DELETE_CHILD) {
                out ` delete child $(change.name)`;
            } else if (change.type == CHANGE_WRITE) {
                out ` write\n`;
            } else if (change.type == CHANGE_RESIZE) {
                out ` resize to $(change.newSize)`;
            }
        }

        void formatTo(Formatter out, CachedNode n, int index) {
            if (change.path && index < change.path.count()) {
                n.__populateChildren(true);
                entry := n.__children[change.path[index]];
                out I`$(entry.entry.name)`;
                out `($(change.path[index]))/`;
                if (!entry.node && !entry.entry.hash) {
                    out `<NULL HASH>`;
                    formatChange(out);
                    return;
                }
                formatTo(out, entry.getNode(), ++index);
            } else {
                formatChange(out);
            }
        }

        void formatTo(Formatter out) {
            formatTo(out, node, 0);
        }
    }

    void __applyChange(Change change) {
        if (change.type == CHANGE_ADD_CHILD) {
            __addChild(change.name, CachedNode(__ctx, null, change.node));
        } else if (change.type == CHANGE_DELETE_CHILD) {
            if (!__populateChildren(false) || !__children.delete(change.name))
                throw InvalidStateError(
                    FStr() `replaying delete: can't delete child $(change.name)`
                );
            __markDirty();
        } else if (change.type == CHANGE_WRITE) {
            __write(uint64(change.pos), change.data);
        } else if (change.type == CHANGE_RESIZE) {
            __resize(uint64(change.newSize));
        } else {
            error `Unrecognized change type $(change.type)`;
        }
    }

    ## Lookup a change in the descendent tree, return the descendant that the
    ## change applies to.
    CachedNode __lookup(Change change, int index) {
        if (!change || !change.path || index >= change.path.count())
            return this;

        # Get the child index from the path.
        childIndex := change.path[index];
        @assert(node.children && childIndex < node.children.count());
        __populateChildren(false);
        return __children[childIndex].getNode().__lookup(change, index + 1);
    }

    ## Replay all journal entries against the node.  If the node doesn't have
    ## a digest or there are no changes, does nothing.  Should only be used on
    ## the root node.
    void replayJournal() {
        if (parent)
            throw InvalidArgumentError('Replay journal only works against the '
                                        'root node.'
                                       );

        String lastChangeDigest;
        for (entry :in __ctx.makeJournalIter()) {
            change := entry.change;
            if (!lastChangeDigest) {
                # First change after a commit.  Verify that the change has a
                # commit hash that matches the last commit.
                if (!change.commit)
                    throw InvalidStateError('First change in the journal '
                                             'does not have a commit field.'
                                            );
                if (change.commit != __ctx.getBaselineCommit())
                    throw InvalidStateError(
                        FStr() I`First change in the journal is for commit \
                                 $(altEncode(change.commit)), current commit \
                                 is $(altEncode(__ctx.getBaselineCommit()))`
                    );
            } else if (lastChangeDigest != change.lastChange) {
                throw InvalidStateError(
                    FStr() I`Change $(altEncode(entry.digest)) should be \
                             applied to $(altEncode(change.lastChange)). \
                             last change was $(altEncode(lastChangeDigest)).`
                );
            }
            node := __lookup(change, 0);
            @assert(node);
            node.__applyChange(change);
            lastChangeDigest = entry.digest;
        }

        # Store this in the context.
        __ctx.setLastChange(lastChangeDigest);
    }

    uint read(uint64 pos, WriteBuffer buffer) {
        __touched();
        if (pos > node.size)
            return 0;

        buffer.size = 0;
        if (node.contents) {

            # We've got contents, read from there.
            if (pos < node.contents.size) {
                uint size;
                if (buffer.cap >= node.contents.size - pos)
                    size = node.contents.size - pos;
                else
                    size = buffer.cap;
                buffer.move(0, node.contents.buffer + pos,
                            size
                            );
                buffer.size = size;
            } else {
                buffer.size = 0;
            }
        } else if (node.children) {

            WriteBuffer frame = {null, 0, 0};
            @assert(__populateChildren(false));
            for (child :in __children) {
                if (pos < child.getSize()) {

                    # Delegate the operation to the child

                    # Make the frame buffer the remaining part of the input
                    # buffer.
                    frame.buffer = buffer.buffer + buffer.size;
                    frame.cap = buffer.cap - buffer.size;
                    frame.size = 0;

                    # Pass this off to the child.
                    amtRead := child.getNode().read(pos, frame);
                    buffer.size += amtRead;

                    # Quit if we've filled the buffer.
                    if (buffer.size == buffer.cap)
                        break;

                    # Reset pos to zero so we start at the beginning of the
                    # next child.
                    pos = 0;
                } else {
                    # Fix the position to be relative to the start of the next
                    # child.
                    pos -= child.getSize();
                }
            }
        }

        return buffer.size;
    }

    void garbageCollect() {
        # TODO: move this entirely into the NodeContext.
        totalSize := getRoot().getRSize();
        if (totalSize > __ctx.getGCThreshold()) {
            info I`running garbage collection (total size $totalSize \
                   threshold = $(__ctx.getGCThreshold())`;
            __ctx.garbageCollect();
        }
    }

    @struct VerifyReport {
        uint64 size;
        uint depth;
    }

    VerifyReport verify() {

        # If the node isn't dirty, verify that we have a correct digest.
        if (!dirty) {
            @assert(digest);
            @assert(digest == __ctx.makeDigest(node));
        }

        if (node.contents) {
            @assert(node.contents.size == node.size);
            @assert(node.contents.size <= __ctx.getMaxContentSize());
            return VerifyReport(node.contents.size, 1);
        } else if (node.children) {
            @assert(__populateChildren(false));
            @assert(node.children.count() == __children.count());
            uint64 totalSize;
            uint depth = 0;
            for (child :in __children) {
                childReport := child.getNode().verify();
                @assert(child.getSize() == childReport.size);
                @assert(child.getParent() is this);
                @assert(child.getNode().parent is this);
                totalSize += childReport.size;
                if (depth) {
                    @assert(depth == childReport.depth);
                } else {
                    depth = childReport.depth;
                }
            }
            @assert(node.size == totalSize);

            return VerifyReport(totalSize, depth + 1);
        } else {
            return VerifyReport(0, 1);
        }
    }

    void formatTo(Formatter out) {
        indent := Indenter.wrap(out);
        indent `CachedNode {\n`;
        __populateChildren(false);
        ++indent;
        int min(int a, int b) { return (a < b) ? a : b }
        indent I`hash: $(digest ? altEncode(digest) : 'null')
                 size: $(node.size)
                 contents: $(!(node.contents is null) ?
                                node.contents.substr(0, min(node.contents.size,
                                                         10)).getRepr() :
                                'null'
                             )
                 entries: $__children\n`;
        --indent;
        indent `}`;
    }

    ## Pre-order traverse all resident nodes in the tree.
    void traverseResident(Functor1[void, CachedNode] callback) {
        callback(this);
        if (__children) {
            for (child :in __children) {
                if (child.node)
                    child.node.traverseResident(callback);
            }
        }
    }
}

CachedNode _makeCachedNode(CachedNode parent, NodeContext ctx, String digest) {
    node := ctx.getNode(digest);
    if (!node)
        return null;

    result := CachedNode(ctx, digest, node.clone());
    result.parent = parent;
    return result;
}
