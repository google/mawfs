#!/usr/local/bin/crack
# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import crack.ascii hex, radix;
import crack.cmdline CmdOptions, Option, CMD_STR;
import crack.enc.base64 altDecode, altEncode;
#import crack.exp.fuse fuseMain = main, LockedFilesystem, NodeImpl;
import crack.lang Exception, InvalidArgumentError, SystemError;

import crack.fs cwd, makePath, Path;
import crack.net Address;
import crack.process Process, CRK_PIPE_STDERR, CRK_PIPE_STDOUT;
import crack.runtime abort, backtrace, close, free, getLocation, isatty,
    memcmp, open, sigaction, strlen, SigAction, SigInfo, O_RDONLY,
    SA_SIGINFO, SIGFPE, SIGILL, SIGSEGV;
import crack.strutil StringArray;
import crack.sys argv, exit;
import crack.io cin, cout, cerr, Formatter, FStr, Reader, StandardFormatter,
    StringFormatter, StringReader;

import crack.hash.sha256 SHA256;

import crack.cont.array Array;
import crack.io.readers LineReader;
import crack.lang AppendBuffer, InvalidStateError;
import crack.logger cerrLogger;
import crack.logger debug, error, setLogFile, setLogLevel, DEBUG;
import crack.logger.ctx Log;
import crack.net.comm2 Comm;
import crack.protobuf readMessageFromString;
import crack.threads Mutex;

import mawfs.blockstore hashFile, ChunkStore, FSInfo, Node, BLOCK_SIZE;
import mawfs.configstore ConfigStore;
import mawfs.fuse runFuse, UserModule;
import mawfs.flows MAWFSInstance;
import mawfs.params DeviceEntropySource, ParamInfo;
import mawfs.peernet PeerNetwork;
import mawfs.rawchunk RawChunkReader;
import mawfs.rpc parseAddr, setInst, PeerProxy;
import mawfs.util traverse;

@import crack.ann impl;

import 'libc.so.6' fsync;
int fsync(int fd);

#class DirNode : NodeImpl {
#    @static DirNode readFrom(Reader src) {

#void mount(String backing, String mountPoint) {
#
#    backingRoot := makePath(backing);
#    fuseMain(StringArray!['<mawfs>', mountPoint], LockedFilesystem(backingRoot));
#    # xxxx finish writing xxxxx
#}

# Lifted from crack.lang.

const _ADDRS_SIZE := 100;
const array[voidptr] _addrs = {_ADDRS_SIZE};
const array[byteptr] _addrInfo = {3};

void trapHandler(int signal, SigInfo si, voidptr ucontext) {
    StringFormatter trace = {};
    trace `Stack Trace\n`;
    numFrames := backtrace(_addrs, _ADDRS_SIZE);
    if (numFrames == _ADDRS_SIZE)
        trace `    [stack trace truncated]\n`;
    for (int i = numFrames - 1; i; --i) {
        getLocation(_addrs[i], _addrInfo);
        if (strlen(_addrInfo[0]) >= 8 &&
            !memcmp(_addrInfo[0], ':unknown'.buffer, 8)) {
            trace `    unknown address\n`;
        } else {
            trace `    $(_addrInfo[0])\n`;
        }
    }

    if (signal == SIGSEGV)
        trace `    SIGSEGV received\n`;
    else if (signal == SIGILL)
        trace `    SIGILL received\n`;
    else if (signal == SIGFPE)
        trace `    SIGFPE received\n`;
    else
        trace `    Unexpected signal received\n`;

    error `$(trace.string())\n`;

    abort();
}

void dumpNode(Formatter out, Node node) {
    if (node.checksum)
        out `checksum: $(node.checksum)\n`;
    if (!(node.contents is null))
        out `contents: $(node.contents.getRepr())\n`;
    out `mode: $(node.mode)\n`;
    out `size: $(node.size)\n`;
    if (node.children) {
        out `children:\n`;
        for (child :in node.children) {
            out `-  hash: $(hex(child.hash))\n`;
            if (child.name)
                out `   name: $(child.name)\n`;
            if (child.org_checksum)
                out `   org_checksum: $(child.org_checksum)\n`;
        }
    }
}

void usage() {
    cerr I`\
        Usage:
            mawfs run <backing> <mountpoint>
                Mount a mawfs filesystem.
            mawfs hash <filename> ...
                Show file hashes.
                the correct way to do this.
            mawfs storechunk <src-file>
                Reads data from <src-file> and writes it to the filesystem
                under its digest name.
            mawfs loadchunk <hash>
                Loads a chunk based on its digest and writes it to standard
                output.
            mawfs dump <filename>
                Dump the contents of an encrypted backing file.
        `;
}

## Returns a reader for the file specified by 'filename'.  If 'filename' is
## "-", returns a reader for standard input.
Reader getReader(String filename) {
    if (filename == '-') {
        return cin;
    } else {
        return makePath(filename).reader();
    }
}

class RPCCmd {
    PeerProxy __proxy;
    Log __log;
    Comm __comm;

    oper init(String addr) {
        __log = Log(cerrLogger, 'client');
        __comm = Comm(__log);
        __comm.start();
        __proxy = PeerProxy(__comm, __log, addr);
    }

    oper del() {
        __comm.stop();
    }

    void pullBranch(String branch, String peer) {
        localName := __proxy.pullBranch(branch, peer);
        cerr `Branch loaded into $localName\n`;
    }
}

RPCCmd makeRPC(String addr) {
    return RPCCmd(addr);
}

String readPassword() {
    String password;
    if (isatty(0)) {
        lr := LineReader(cin);

        p := Process(StringArray!['/bin/stty', '-g'],
                     CRK_PIPE_STDOUT | CRK_PIPE_STDERR);
        orig_term_settings := p.getStdOut().rtrim();
        cmd_err := p.getStdErr().rtrim();
        if (cmd_err != "") {
            throw InvalidStateError('Got an error from stty; terminal may '
                                    'be in a bad state');
        }

        p = Process(StringArray!['/bin/stty', '-echo'],
                     CRK_PIPE_STDOUT | CRK_PIPE_STDERR);
        cmd_err = p.getStdErr().rtrim();
        if (cmd_err != "") {
            throw InvalidStateError('Got an error from stty; terminal may '
                                    'be in a bad state');
        }

        cout `password: `;
        password = lr.readLine().rtrim();
        cout `\n`;

        p = Process(StringArray!['/bin/stty', orig_term_settings],
                     CRK_PIPE_STDOUT | CRK_PIPE_STDERR);
        cmd_err = p.getStdErr().rtrim();
        if (cmd_err != "") {
            throw InvalidStateError('Got an error from stty; terminal may '
                                    'be in a bad state');
        }
    } else {
        lr := LineReader(cin);
        password = lr.readLine().rtrim();
    }

    hasher := SHA256();
    hasher.update(password);
    hashed_password := hasher.digest();

    return hashed_password;
}

class Abort : Exception {
    oper init(String message) : Exception(message) {}
}

## initializes the chunk store from disk.  Reads the password from the user.
ChunkStore makeChunkStore(Path backingDir) {
    password := readPassword();
    entropy := DeviceEntropySource(makePath('/dev/urandom'));
    paramsFile := backingDir/'params';
    ParamInfo params;

    if (backingDir.exists() && paramsFile.exists()) {
        params = ParamInfo.read(backingDir/'params', password);
        if (!params)
            throw Abort('Invalid password');
    } else {
        # Write a new params file.
        if (!backingDir.exists())
            backingDir.makeDir();
        params = ParamInfo.getDefault(password);
        params.writeTo((backingDir/'params').writer(), entropy);
    }

    return ChunkStore(backingDir, FSInfo(params.cipher));
}

opts := CmdOptions![
    Option('logfile', 'l', 'logfile name', 'mawfs.log', CMD_STR),
    Option('branch', 'b', 'branch name', 'master', CMD_STR),
];

# The main function, which is a command dispatcher.
void main() {
    args := opts.parse();
    if (args.count() < 2) {
        usage();
        exit(1);
    }

    try {
        cmd := args[1];
        if (cmd == 'hash') {
            if (args.count() < 3) {
                cerr `No files specified\n`;
                exit(1);
            }
            for (file :in args.subarray(2))
                cout `$(hex(hashFile(makePath(file)))) $file\n`;
        } else if (cmd == 'mount') {
            cerr `"mount" doesn't work, use "run"]\n`;
            exit(1);
#            if (args.count() != 4) {
#                cerr `Usage: mawfs mount <backing-store> <mount-point>\n`;
#                exit(1);
#            }
#
#            mount(args[2], args[3]);
        } else if (cmd == 'storechunk') {
            if (args.count() != 3) {
                cerr `Usage: mawfs storechunk <src-file>`;
                exit(1);
            }

            # Read the file contents.
            src := getReader(args[2]);
            contents := AppendBuffer(BLOCK_SIZE);
            while (data := src.read(BLOCK_SIZE))
                contents.extend(data);

            store := makeChunkStore(cwd);
            digest := store.store(contents);
            cout `$(hex(digest))\n`;
        } else if (cmd == 'loadchunk') {
            if (args.count() != 3) {
                cerr `Usage: mawfs loadchunk <hash>\n`;
                exit(1);
            }

            store := makeChunkStore(cwd);
            chunk := store.load(altDecode(args[2]));
            if (!chunk)
                cerr `Chunk $(args[2]) not found\n`;
            else
                cout `$(chunk.contents)`;
        } else if (cmd == 'commit') {
            if (args.count() < 3) {
                cerr I`Usage: commit <mount-point>\n`;
                exit(1);
            }

            fd := open(args[2].buffer, O_RDONLY, 0);
            if (fd == -1) {
                cerr `Unable to open $(args[2]): c_strerror()\n`;
                exit(1);
            } else {
                fsync(fd);
                close(fd);
                cerr `Synced.\n`;
            }
        } else if (cmd == 'run') {
            if (args.count() < 4) {
                cerr I`Usage: mawfs run [-b branch] <backing-dir> [fuse-options] \
                       <mount-point>\n`;
                exit(1);
            }

            sa := SigAction();
            sa.sa_sigaction = trapHandler;
            sa.sa_flags = SA_SIGINFO;
            sigaction(SIGSEGV, sa, null);
            sigaction(SIGILL, sa, null);
            sigaction(SIGFPE, sa, null);
            free(sa);
            sa = null;

            StringArray fuseArgs = [args[0]];
            fuseArgs.extend(args.subarray(3));

            setLogFile(opts.getString('logfile'));
            setLogLevel(DEBUG);
            rootDir := makePath(args[2]);
            configStore := ConfigStore(rootDir, 'peers');
            chunkStore := makeChunkStore(rootDir);

            # Start the peer network.
            mutex := Mutex();
            chunkReader := chunkStore.getRawChunkReader(mutex);

            class PeerNetModule @impl UserModule {
                PeerNetwork __net;
                ConfigStore __config;
                RawChunkReader __chunkReader;
                ChunkStore __store;
                Path __root;

                oper init(ConfigStore config, RawChunkReader chunkReader,
                          ChunkStore store,
                          Path root
                          ) :
                    __config = config,
                    __chunkReader = chunkReader,
                    __store = store,
                    __root = root {
                }

                void start() {
                    __net = PeerNetwork(__chunkReader);
                    __net.configure(__config);
                    setInst(MAWFSInstance(__root, __store, __net));
                }
            }

            runFuse(chunkStore, fuseArgs, opts.getString('branch'), mutex,
                    PeerNetModule(configStore, chunkReader, chunkStore, rootDir)
                    );
        } else if (cmd == 'pull') {
            if (args.count() != 4) {
                cerr `Usage: mawfs pull <peer-address> <backing-dir>\n`;
                exit(1);
            }

            Address peerAddr;
            try {
                peerAddr = parseAddr(args[2]);
            } catch (Exception ex) {
                cerr I`Invalid address specification for peer address: \
                       $(args[2])\n`;
                exit(1);
            }
            backingDirName := args[3];

            setLogFile('mawfs-puller.log');
            setLogLevel(DEBUG);

            # Create the directory if it doesn't exist.
            backingDir := makePath(backingDirName);
            backingDir.makeDirs();

            import mawfs.blockstore RemoteReader;

            class RemoteReaderImpl @impl RemoteReader {
                PeerNetwork __net;

                oper init(PeerNetwork net) : __net = net {}

                String getContents(String digest) {
                    return __net.getObject(digest);
                }
            }

            password := readPassword();

            # Only need a raw chunk reader if we're running a server, so we
            # can give it a null.
            net := PeerNetwork(null);
            net.addPeer(peerAddr);

            # If there's no params file, get one.
            ChunkStore store;
            if (!(backingDir/'params').exists()) {
                paramInfo := net.pullParams(backingDir, password);
                if (!paramInfo) {
                    cerr `No peers found.\n`;
                    exit(1);
                }
                store = ChunkStore(backingDir, FSInfo(paramInfo.cipher));
            } else {
                store = ChunkStore(backingDir, FSInfo(password));
                # TODO: verify that the params are the same.
            }

            store.setRemoteReader(RemoteReaderImpl(net));

            master := net.getHead('master');
            cerr `master is $(altEncode(master))\n`;
            net.pullJournal(backingDir, 'master');

            cerr `getting head\n`;
            head := store.getCommit(master);
            traverse(store, head);

            cerr `writing master...\n`;
            refsDir := backingDir/'refs';
            refsDir.makeDirs();
            (refsDir/'master').writeAll(altEncode(master));
        } else if (cmd == 'dump') {
            if (args.count() != 3) {
                cerr I`Usage: mawfs dump <path>`;
                exit(1);
            }

            password := readPassword();

            path := makePath(args[2]);
            contents := path.readAll();

            # See if this is a tag.
            if (contents.count() == 64 &&
                ((refed := path.parent()/altDecode(contents))).exists()
                )
                contents = refed.readAll();

            # Read it.
            chunk := FSInfo(password).readChunk(StringReader(contents));
            Node node = {};
            readMessageFromString(node, chunk.contents);
            dumpNode(cout, node);
        } else if (cmd == 'fetch') {
            if (args.count() < 4 || args.count() > 5) {
                cerr I`Usage: mawfs fetch <addr> <branch> [peer]\n`;
                exit(1);
            }

            setLogLevel(DEBUG);
            makeRPC(args[2]).pullBranch(args[3],
                                        (args.count() > 4) ? args[4] : null
                                        );
        } else {
            cerr `Unknown command: $cmd\n`;
            usage();
            exit(1);
        }
    } catch (Abort ex) {
        cerr `$(ex.text)\n`;
    } catch (SystemError ex) {
        cerr `system error: $ex\n`;
        error `$(ex.text)`;
    } catch (InvalidArgumentError ex) {
        cerr `invalid argument: $ex\n`;
        error `$(ex.text)`;
    } catch (Exception ex) {
        cerr `general exception: $ex\n`;
        error `got general exception: $ex\n`;
    }
}

main();
