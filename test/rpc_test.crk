
import crack.functor Functor1;
import crack.io cerr, FStr;
import crack.lang Exception;
import crack.logger.ctx Log;
import crack.net InetAddress, Poller, PollEvent, PollEventCallback, Socket,
    SocketApd, AF_INET, SOCK_STREAM;
import crack.net.comm2 Comm, CommListener, WaiterFor;
import mawfs.aes_siv SIVCipher;
import mawfs.ciphers sha256, Cipher;
import mawfs.rawchunk GeneralCallback, JournalBlock, RawChunkReader;
import mawfs.rpc setInst, Context, InfoResponse, InstIFace, LoginError,
    LoginState, MergeResponse, PeerProxy, PeerServiceCommFactory;

@import crack.ann assert, impl;

## A socket initialization callback that captures the port number.
class PortCollectorCallback @impl Functor1[void, Socket] {

    ## Wait on this to get the port number.
    WaiterFor[int, int] waiter = {0};

    void oper call(Socket sock) {
        s := SocketApd(Socket.cast(sock));
        InetAddress addr = {0, 0};
        s.getSocketAddress(addr);
        port := addr.getPort();
        waiter.setResult(port);
    }
}

class FakeChunkReader @impl RawChunkReader {
    void readRawChunk(String digest, GeneralCallback[String] callback) {
        callback('from the chunk reader', null);
    }

    void getHead(String branch, GeneralCallback[String] callback) {
        callback('digest', null);
    }

    void getJournalBlock(String firstBlockDigest, String branch, uint pos,
                         GeneralCallback[JournalBlock] callback) {
        callback(JournalBlock(firstBlockDigest, branch + ' contents', pos > 0),
                 null
                 );
    }

    void getFile(String filename, GeneralCallback[String] callback) {
        callback('contents', null);
    }
}

class FakeInstance @impl InstIFace {
    Cipher cipher;

    oper init(Cipher cipher) : cipher = cipher {}

    void pullBranch(String branch, String peer,
                    GeneralCallback[String] callback
                    ) {
    }

    void merge(String branch, GeneralCallback[MergeResponse] callback) {}

    void resolve(GeneralCallback[int] callback) {}
    void cancelMerge(GeneralCallback[int] callback) {}
    void addPeer(String peerName, String peerAddr,
                 GeneralCallback[int] callback
                 ) {
    }
    InfoResponse getInfo() { return null }

    LoginState answerChallenge(String challenge) {
        class FakeLoginState : LoginState {
            String expected;
            oper init(String challenge, String response, String expected) :
                expected = expected {

                this.challenge = challenge;
                this.response = response;
            }

            bool verifyResponse(String response) {
                return response == expected;
            }
        }

        decrypted := cipher.decrypt(challenge);
        if (!decrypted)
            throw LoginError('Invalid challenge');
        response := cipher.encrypt(sha256(decrypted));
        myChallenge := 'challenge';
        expected := cipher.encrypt(sha256(myChallenge));
        return FakeLoginState(cipher.encrypt(myChallenge), response,
                              expected
                              );
    }

    bool validNonce(String nonce) {
        return nonce == 'nonce';
    }
}


class RPCTestBed {

    Comm comm;
    Log log;
    Context context;

    ## Server port number.
    int port;

    Cipher cipher = SIVCipher(sha256('weak password'), null);

    void startServer() {
        portCallback := PortCollectorCallback();
        context = Context(FakeChunkReader());
        context.authenticated = true;
        listener := CommListener(log, PeerServiceCommFactory(context));
        listener.addSocketInitCallback(portCallback);
        comm.startServer(InetAddress(127, 0, 0, 1, 0), listener, true);
        port = portCallback.waiter.getResult();

        setInst(FakeInstance(cipher));
    }

    void setUp() {
        log = Log(null, cerr, cerr, cerr, cerr, 'server');
        comm = Comm(log);
        comm.start();
        startServer();
    }

    void testGetObject() {
        peer :=
            PeerProxy.make(comm, Log(log, 'client'), FStr() `127.0.0.1:$port`);
        @assert(peer.getObject('foo') == 'from the chunk reader');
    }

    void testGetHead() {
        peer :=
            PeerProxy.make(comm, Log(log, 'client'), FStr() `127.0.0.1:$port`);
        @assert(peer.getHead('master') == 'digest');
    }

    void testReadJournal() {
        peer :=
            PeerProxy.make(comm, Log(log, 'client'), FStr() `127.0.0.1:$port`);
        jb := peer.getJournalBlock('digest', 'branch', 0);
        @assert(jb.firstBlockDigest == 'digest');
        @assert(jb.contents == 'branch contents');
        @assert(!jb.done);

        jb = peer.getJournalBlock('digest', 'branch', 1);
        @assert(jb.done);
    }

    void testGetFile() {
        peer :=
            PeerProxy.make(comm, Log(log, 'client'), FStr() `127.0.0.1:$port`);
        @assert(peer.getFile('filename') == 'contents');
    }

    void testPeerLogin() {
        context.authenticated = false;
        peer := PeerProxy.make(comm, Log(log, 'client'),
                               FStr() `127.0.0.1:$port`);
        peer.login(cipher);
        @assert(context.authenticated);
    }

    void testFailingPeerLogin() {
        context.authenticated = false;
        peer := PeerProxy.make(comm, Log(log, 'client'),
                               FStr() `127.0.0.1:$port`);
        try {
            peer.login(SIVCipher(sha256('wrong password'), null));
            @assert(false);
        } catch (LoginError ex) {
        }
        @assert(!context.authenticated);
    }

    void testUserLogin() {
        context.authenticated = false;
        peer := PeerProxy.make(comm, Log(log, 'client'),
                               FStr() `127.0.0.1:$port`);
        peer.login('nonce');
        @assert(context.authenticated);
    }

    void testFailedUserLogin() {
        context.authenticated = false;
        peer := PeerProxy.make(comm, Log(log, 'client'),
                               FStr() `127.0.0.1:$port`);
        try {
            peer.login('badnonce');
            @assert(false);
        } catch (LoginError ex) {
        }
        @assert(!context.authenticated);
        context.authenticated = true;
    }

    void tearDown() {
        comm.stop();
    }
}

testbed := RPCTestBed();
testbed.setUp();
try {
    testbed.testGetObject();
    testbed.testGetHead();
    testbed.testReadJournal();
    testbed.testGetFile();
    testbed.testPeerLogin();
    testbed.testFailingPeerLogin();
    testbed.testUserLogin();
    testbed.testFailedUserLogin();
} catch (Exception ex) {
    testbed.tearDown();
    throw ex;
}

cerr `ok\n`;

