# Copyright 2018 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import crack.io cerr;
import crack.strutil StringArray;

import mawfs.blockstore Entry, Node, MODE_DIR;
import mawfs.memstore MemNodeStore;
import mawfs.cache CachedNode, NodeContext;
import mawfs.merge merge3, Conflict, Mutation, UNCHANGED;

import test.unittest register, runAllTests, Test;

@import crack.ann assert;

@abstract class MergeTest : Test {
    MemNodeStore store = {};
    NodeContext ctx;
    String rootDigest;
    Node rootNode;

    void setUp() {
        rootNode = Node();
        rootNode.mode = MODE_DIR;
        rootDigest = store.storeNode(rootNode);
        ctx = NodeContext(store, 'master', rootDigest);
    }

    CachedNode makeDirNode() {
        return CachedNode(ctx, rootDigest, rootNode.clone());
    }

    CachedNode makeFileNode(String contents) {
        node := Node();
        node.contents = contents;
        node.size = contents ? contents.count() : 0;
        digest := store.storeNode(node);
        return CachedNode(ctx, digest, node);
    }
}

class NameTreeTest : Test {
    void run() {
        alias T = Conflict.NameTree;
        alias E = T.Entry;
        tree := T![
            E('a', null),
            E('b', T![
                E('x', T![
                    E('h', null),
                    E('i', null)
                ]),
                E('y', T![
                    E('j', null),
                ]),
            ]),
            E('c', T![E('z', null)]),
        ];

        flattened := StringArray();
        for (name :in tree)
            flattened.append(name);

        @assert(flattened ==
                 StringArray!['a', 'b/x/h', 'b/x/i', 'b/y/j', 'c/z']
                );
    }
}
register(NameTreeTest());

class SimpleMerge : MergeTest {
    void run() {
        root := makeDirNode();

        # Verify that both the org and other can be null.
        @assert(merge3(root, null, null) is UNCHANGED);

        # If target and other are the same, no change.
        @assert(merge3(root, null, root) is UNCHANGED);

        # If other and org are the same and target has diverged, no change.
        @assert(merge3(null, root, root) is UNCHANGED);

        # If target and org are the same and other has diverged, get a
        # mutation for other.
        other := makeFileNode('contents');
        @assert(merge3(root, root, other) == Mutation(other));
    }
}
register(SimpleMerge());


class FileMerge : MergeTest {
    void run() {
        org := makeFileNode('org');
        a := makeFileNode('first');
        b := makeFileNode('second');
        @assert(merge3(a, org, b) == Conflict());
    }
}
register(FileMerge());

runAllTests();

