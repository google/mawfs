# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import crack.fs makePath, Path;
import crack.hash.sha256 SHA256;
import crack.io cerr;
import crack.lang Exception;
import crack.logger cerrLogger, info, setLogFile, setLogLevel, DEBUG;
import crack.logger.ctx Log;
import crack.net InetAddress;
import crack.net.comm2 Comm;
import crack.runtime sleep;
import crack.threads Mutex;

import mawfs.blockstore ChunkStore, Commit, FSInfo, Node, MODE_DIR;
import mawfs.cache Tree;
import mawfs.flows MAWFSInstance;
import mawfs.path MAWFSPath;
import mawfs.peernet PeerNetwork, RemoteReaderImpl;
import mawfs.params ParamInfo;
import mawfs.rpc setInst, PeerProxy;
import mawfs.testutil FakeEntropySource;

@import crack.ann assert;

String expandPassword(String pw) {
    hasher := SHA256();
    hasher.update(pw);
    return hasher.digest();
}

const MASTER_PORT := 9130;
const SLAVE_PORT := 9131;
const PASSWORD := expandPassword('password');

class TestFailure : Exception {
    oper init(String text) : Exception(text) {}
}

class PeerInfo {
    Path backDir;
    int port;
    PeerNetwork peerNet;
    ChunkStore cs;

    oper init(Path backDir, int port) : backDir = backDir, port = port {}

    void create() {
        if (backDir.exists())
            backDir.deleteTree();
        backDir.makeDirs();

        # Create params and chunk store.
        params := ParamInfo.getDefault(PASSWORD);
        params.writeTo((backDir/'params').writer(), FakeEntropySource(10));
        cs = ChunkStore(backDir, FSInfo(params.cipher));

        # Create the peer network.
        mutex := Mutex();
        chunkReader := cs.getRawChunkReader(mutex);
        peerNet = PeerNetwork(chunkReader);

        # Set up a remote reader.
        cs.setRemoteReader(RemoteReaderImpl(peerNet));

        peerNet.addServer(InetAddress(127, 0, 0, 1, port));
    }

    void makeBranch(String branch) {
        rootNode := Node();
        rootNode.mode = MODE_DIR;
        rootDigest := cs.storeNode(rootNode);

        commit := Commit();
        commit.root = rootDigest;
        commitDigest := cs.storeCommit(commit);
        cs.setHead(branch, commitDigest);
    }

    ## Returns a Path object for the root of the head of 'branch'.
    Path getRoot(String branch) {
        tree := Tree(cs, branch);
        return MAWFSPath(tree.getRoot());
    }

    void commit(String branch) {
        Tree(cs, branch).commit();
    }

    void shutdown() {
        # Break the reference cycle that I don't really understand.
        cs.setRemoteReader(null);
        peerNet.shutdown();
    }
}

@abstract class TestBed {

    Path root;
    PeerInfo master, slave;
    Comm comm;
    PeerProxy proxy;

    bool failed;

    void createMaster() {
        backDir := root/'back0';
        master = PeerInfo(backDir, MASTER_PORT);
        master.create();
    }

    void createSlave() {
        backDir := root/'back1';
        slave = PeerInfo(backDir, SLAVE_PORT);
        slave.create();

        # The slace gets the MAWFS instance, he's the one we're communicating
        # to.
        setInst(MAWFSInstance(backDir, slave.cs, slave.peerNet));
    }

    int getPort() { return SLAVE_PORT }

    void setUp() {
        root = makePath('tmp');
        createMaster();
        createSlave();
        slave.peerNet.addPeer(InetAddress(127, 0, 0, 1, MASTER_PORT));

        log := Log(cerrLogger, 'client-proxy');
        comm = Comm(log);
        comm.start();
        proxy = PeerProxy(comm, log, InetAddress(127, 0, 0, 1, getPort()));
    }

    void tearDown() {
        master.shutdown();
        slave.shutdown();
        proxy.shutdown();
        comm.stop();
        comm = null;
        proxy = null;

        setInst(null);
    }

    @abstract void run();

    void exec() {
        cerr `$(this.class.name)...`;
        info `==== begin $(this.class.name) ===`;
        setUp();
        try {
            run();
            cerr `ok\n`;
        } catch (TestFailure ex) {
            cerr `FAILED\n\t$(ex.text)\n`;
            failed = true;
        } catch (Exception ex) {
            sleep(1);
            cerr `FAILED\n`;
            cerr `$ex\n`;
            failed = true;
        }
        tearDown();
        info `---- end $(this.class.name) ----`;
    }
}

setLogFile('net_test.log');
setLogLevel(DEBUG);

class ServerConnectionsTest : TestBed {
    int getPort() { return MASTER_PORT }
    void run() {
        @assert(proxy.getFile('params') == (master.backDir/'params').readAll());
    }
}
ServerConnectionsTest().exec();

const FILE_CONTENTS := 'Test File!';

class FetchTest : TestBed {
    void run() {
        master.makeBranch('foo');

        branchName := proxy.pullBranch('foo', null);
        @assert(branchName == 'foo');

        # Create a branch with a journal.
        master.makeBranch('bar');
        (master.getRoot('bar')/'temp.txt').writeAll(FILE_CONTENTS);

        branchName = proxy.pullBranch('bar', null);
        @assert(branchName == 'bar');
        @assert((slave.getRoot('bar')/'temp.txt').readAll() == FILE_CONTENTS);

        # Pull from the same branch again after making changes to it.  We
        # should just get the latest from the new branch, since there are no
        # changes to the local one.
        (master.getRoot('bar')/'moar.txt').writeAll(FILE_CONTENTS);
        branchName = proxy.pullBranch('bar', null);
        @assert(branchName == 'bar');
        @assert((slave.getRoot('bar')/'moar.txt').readAll() ==
                FILE_CONTENTS
                );

        # Extend the local journal, verify that it doesn't get changed.
        (slave.getRoot('bar')/'evenmoar.txt').writeAll(FILE_CONTENTS);
        branchName = proxy.pullBranch('bar', null);
        @assert(branchName == 'bar');
        @assert((slave.getRoot('bar')/'evenmoar.txt').readAll() ==
                FILE_CONTENTS
                );

        # Extend the remote journal incompatibly.
        (master.getRoot('bar')/'evilmoar.txt').writeAll(FILE_CONTENTS);
        branchName = proxy.pullBranch('bar', null);
        @assert(branchName != 'bar');
        @assert(!(slave.getRoot('bar')/'evilmoar.txt').exists());
        @assert((slave.getRoot(branchName)/'evilmoar.txt').readAll() ==
                FILE_CONTENTS
                );
    }
}
FetchTest().exec();

# Verify that we do the right thing when fetching from branches based on
# completely different commits.
class DiffCommitsTest : TestBed {
    void run() {
        master.makeBranch('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');

        # Verify that a second pull shows up as the same.
        @assert(proxy.pullBranch('foo', null) == 'foo');

        # Verify that a new descendant commit subsumes the branch when there
        # is no local journal.
        (master.getRoot('foo')/'test').writeAll(FILE_CONTENTS);
        master.commit('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo')
        @assert((slave.getRoot('foo')/'test').readAll() == FILE_CONTENTS);

        # Verify that a new local commit is left intact if the remote commit
        # is older.
        (slave.getRoot('foo')/'localFile').writeAll(FILE_CONTENTS);
        slave.commit('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');
        @assert((slave.getRoot('foo')/'localFile').readAll() == FILE_CONTENTS);

        # Verify that we now branch on a new remote commit.
        (master.getRoot('foo')/'branchFile').writeAll(FILE_CONTENTS);
        master.commit('foo');
        newBranch := proxy.pullBranch('foo', null);
        @assert(newBranch != 'foo');
        @assert((slave.getRoot(newBranch)/'branchFile').readAll() ==
                FILE_CONTENTS
                );

        # Verify that a new journal gets propagated correctly.
        (master.getRoot('foo')/'branchFile2').writeAll(FILE_CONTENTS);
        newBranch = proxy.pullBranch('foo', null);
        @assert(newBranch != 'foo');
        @assert((slave.getRoot(newBranch)/'branchFile2').readAll() ==
                FILE_CONTENTS
                );

        # Verify that all this works if both have journals
        (slave.getRoot('foo')/'localFile2').writeAll(FILE_CONTENTS);
        newBranch = proxy.pullBranch('foo', null);
        @assert(newBranch != 'foo');
        @assert((slave.getRoot(newBranch)/'branchFile2').readAll() ==
                FILE_CONTENTS
                );

        # Verify that we pull correctly on different commits if only the slave
        # has a journal.
        master.commit('foo');
        newBranch = proxy.pullBranch('foo', null);
        @assert(newBranch != 'foo');
        @assert((slave.getRoot(newBranch)/'branchFile2').readAll() ==
                FILE_CONTENTS
                );
    }
}
DiffCommitsTest().exec();

class JournalledCompatibleCommits : TestBed {
    void run() {
        master.makeBranch('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');

        # Verify that a new commit with a journal on the master works like an
        # extension if slave doesn't have a journal.
        (master.getRoot('foo')/'firstFile').writeAll(FILE_CONTENTS);
        master.commit('foo');
        (master.getRoot('foo')/'secondFile').writeAll(FILE_CONTENTS);
        newBranch := proxy.pullBranch('foo', null);
        @assert(newBranch == 'foo');
    }
}
JournalledCompatibleCommits().exec();

# This can be merged into the test above as soon as we can recognize that a
# commit is derived from a journal entry.  Then we can resync the two branches
# in the prior test.
class JournalledCompatibleCommits2 : TestBed {
    void run() {
        master.makeBranch('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');

        # Verify that we don't create a tracking branch in cases where there
        # is a local commit with a journal that extends a remote commit
        # without a journal.
        (slave.getRoot('foo')/'firstFile').writeAll(FILE_CONTENTS);
        slave.commit('foo');
        (slave.getRoot('foo')/'secondFile').writeAll(FILE_CONTENTS);
        newBranch := proxy.pullBranch('foo', null);
        @assert(newBranch == 'foo');
    }
}
JournalledCompatibleCommits2().exec();

## Verify that we don't create a new branch for a reote commit derived
## entirely from a journal that we haven't modified.
class CommitFromKnownJournal : TestBed {
    void run() {
        master.makeBranch('foo');
        (master.getRoot('foo')/'firstFile').writeAll(FILE_CONTENTS);
        @assert(proxy.pullBranch('foo', null) == 'foo');

        master.commit('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');
        @assert((slave.getRoot('foo')/'firstFile').readAll() ==
                FILE_CONTENTS
                );

        # Pull the branch, then write again to master an commit - since the
        # all of the sessions in the local branch should still be contained in
        # the commit, we should not fork.
        (master.getRoot('foo')/'secondFile').writeAll(FILE_CONTENTS);
        @assert(proxy.pullBranch('foo', null) == 'foo');
        (master.getRoot('foo')/'thirdFile').writeAll(FILE_CONTENTS);
        master.commit('foo');
        @assert(proxy.pullBranch('foo', null) == 'foo');

        # Write another change, pull and diverge.  At this point, pulling the
        # commit should result in a fork.
        (master.getRoot('foo')/'fourthFile').writeAll(FILE_CONTENTS);
        @assert(proxy.pullBranch('foo', null) == 'foo');
        (master.getRoot('foo')/'masterFile').writeAll(FILE_CONTENTS);
        master.commit('foo');
        (slave.getRoot('foo')/'slaveFile').writeAll(FILE_CONTENTS);
        newBranch := proxy.pullBranch('foo', null);
        @assert(newBranch != 'foo')
        @assert((slave.getRoot('foo')/'slaveFile').readAll() == FILE_CONTENTS);
        @assert(!(slave.getRoot('foo')/'masterFile').exists());
        @assert((slave.getRoot(newBranch)/'masterFile').readAll() == FILE_CONTENTS);
        @assert(!(slave.getRoot(newBranch)/'slaveFile').exists());
    }
}
CommitFromKnownJournal().exec();

/* This test fails.  Double writeAll() breaky-breaky.
class DoubleWriteAll : TestBed {
    void run() {
        master.makeBranch('foo');
        (master.getRoot('foo')/'file').writeAll(FILE_CONTENTS);
        (master.getRoot('foo')/'file').writeAll(FILE_CONTENTS);
    }
}
DoubleWriteAll().exec();
*/
